import { BaseService } from './base';
import { CreateOrder, CartItem } from '../lib/schemas';
import { OrderStatus } from '@prisma/client';
import { logger } from '@/lib/logger';

export interface OrderCreationData {
  items: CartItem[];
  customer: {
    name: string;
    email: string;
    phone: string;
  };
  delivery?: {
    address: string;
    city: string;
    zip: string;
    instructions?: string;
  };
  orderType: 'PICKUP' | 'DELIVERY';
  subtotal: number;
  deliveryFee: number;
  tax: number;
  total: number;
  notes?: string;
  userId?: string;
}

export interface OrderSearchFilters {
  status?: string[];
  orderType?: 'PICKUP' | 'DELIVERY';
  userId?: string;
  dateFrom?: Date;
  dateTo?: Date;
}

export class OrderService extends BaseService {
  
  // Create a new order
  async createOrder(data: OrderCreationData) {
    logger.debug('OrderService.createOrder starting with:', { 
      itemsCount: data.items.length, 
      customer: data.customer.name,
      orderType: data.orderType,
      total: data.total 
    });
    
    try {
      // Create order + items in a single transaction (fail early on FK/validation)
      const order = await this.db.$transaction(async (tx) => {
        logger.debug('Starting database transaction...');
        
        // Generate order number
        const orderNumber = `ORD-${Date.now().toString().slice(-6)}${Math.random().toString(36).substr(2, 3).toUpperCase()}`;
        logger.debug('Generated order number:', orderNumber);

        // Create the main order
        const created = await tx.order.create({
          data: {
            orderNumber,
            userId: data.userId,
            customerName: data.customer.name,
            customerEmail: data.customer.email,
            customerPhone: data.customer.phone,
            orderType: data.orderType,
            deliveryAddress: data.delivery?.address,
            deliveryCity: data.delivery?.city,
            deliveryZip: data.delivery?.zip,
            deliveryInstructions: data.delivery?.instructions,
            subtotal: data.subtotal,
            deliveryFee: data.deliveryFee,
            tax: data.tax,
            total: data.total,
            status: 'PENDING',
            notes: data.notes || `Order placed via online pizza builder - ${data.items.length} item(s)${data.userId ? ' (Authenticated User)' : ' (Guest)'}`
          }
        });

        logger.debug('Order created in database:', { id: created.id, orderNumber: created.orderNumber });

        // Create order items
        for (const item of data.items) {
          const orderItem = await tx.orderItem.create({
            data: {
              orderId: created.id,
              pizzaSizeId: item.size?.id,
              pizzaCrustId: item.crust?.id,
              pizzaSauceId: item.sauce?.id,
              quantity: item.quantity,
              basePrice: item.basePrice,
              totalPrice: item.totalPrice * item.quantity,
              notes: item.notes || 'Custom Pizza'
            }
          });

          // Add toppings for this order item
          if (item.toppings && item.toppings.length > 0) {
            for (const topping of item.toppings) {
              await tx.orderItemTopping.create({
                data: {
                  orderItemId: orderItem.id,
                  pizzaToppingId: topping.id,
                  quantity: topping.quantity,
                  section: topping.section,
                  intensity: topping.intensity || 'REGULAR',
                  price: topping.price
                }
              });
            }
          }
        }

        logger.debug('Order items created successfully');
        return created;
      });

      // Create pricing snapshots separately; failures here should not rollback the order
      try {
        logger.debug('Creating pricing snapshots...');
        await this.createPricingSnapshots(order.id, data.items);
        logger.debug('Pricing snapshots created successfully');
      } catch (snapshotError) {
        logger.warn('Pricing snapshots failed (non-fatal):', snapshotError);
        // Continue - don't let snapshot failure break the order
      }

      logger.info('Order creation completed successfully:', { id: order.id, orderNumber: order.orderNumber });
      return order;
      
    } catch (error) {
      logger.error('OrderService.createOrder fatal error:', error);
      throw error; // Let route return 5xx
    }
  }
        const orderNumber = `BO${Date.now().toString().slice(-6)}${Math.random().toString(36).substr(2, 3).toUpperCase()}`;
        console.log('üî¢ Generated order number:', orderNumber);

        // Create the order
        const order = await tx.order.create({
          data: {
            orderNumber,
            userId: data.userId,
            customerName: data.customer.name,
            customerEmail: data.customer.email,
            customerPhone: data.customer.phone,
            orderType: data.orderType,
            deliveryAddress: data.delivery?.address,
            deliveryCity: data.delivery?.city,
            deliveryZip: data.delivery?.zip,
            deliveryInstructions: data.delivery?.instructions,
            subtotal: data.subtotal,
            deliveryFee: data.deliveryFee,
            tax: data.tax,
            total: data.total,
            status: 'PENDING',
            notes: data.notes || `Order placed via online pizza builder - ${data.items.length} item(s)${data.userId ? ' (Authenticated User)' : ' (Guest)'}`
          }
        });

        // Create order items
        for (const item of data.items) {
          const orderItem = await tx.orderItem.create({
            data: {
              orderId: order.id,
              pizzaSizeId: item.size.id,
              pizzaCrustId: item.crust.id,
              pizzaSauceId: item.sauce.id,
              quantity: item.quantity,
              basePrice: item.basePrice,
              totalPrice: item.totalPrice * item.quantity,
              notes: item.notes || 'Custom Pizza'
            }
          });

          // Add toppings for this order item
          if (item.toppings && item.toppings.length > 0) {
            for (const topping of item.toppings) {
              await tx.orderItemTopping.create({
                data: {
                  orderItemId: orderItem.id,
                  pizzaToppingId: topping.id,
                  quantity: topping.quantity,
                  section: topping.section,
                  intensity: topping.intensity || 'REGULAR',
                  price: topping.price
                }
              });
            }
          }
        }

        console.log('‚úÖ Order created successfully:', { id: order.id, orderNumber: order.orderNumber });

        // Create pricing snapshots for historical accuracy
        try {
          console.log('üí∞ Creating pricing snapshots...');
          await this.createPricingSnapshots(tx, order.id, data.items);
          console.log('‚úÖ Pricing snapshots created successfully');
        } catch (snapshotError) {
          console.warn('‚ö†Ô∏è Pricing snapshots creation failed, but order will still be created:', snapshotError);
          // Don't let snapshot errors prevent order creation
        }

        console.log('üéâ Order creation complete, returning order:', { id: order.id, orderNumber: order.orderNumber });
        return order;
      });
    } catch (error) {
      console.error('‚ùå Order creation failed with error:', error);
      console.error('‚ùå Error details:', { 
        message: (error as any)?.message, 
        code: (error as any)?.code, 
        stack: (error as any)?.stack?.substring(0, 500) 
      });
      this.handleError(error, 'Order Creation');
    }
  }

  // Get order by order number
  async getOrderByNumber(orderNumber: string) {
    try {
      const order = await this.db.order.findUnique({
        where: { orderNumber },
        include: {
          orderItems: {
            include: {
              pizzaSize: true,
              pizzaCrust: true,
              pizzaSauce: true,
              toppings: {
                include: {
                  pizzaTopping: true
                }
              }
            }
          }
        }
      });

      if (!order) {
        throw new Error('Order not found');
      }

      return order;
    } catch (error) {
      this.handleError(error, 'Get Order by Number');
    }
  }

  // Get orders with filters (for kitchen/admin)
  async getOrders(filters: OrderSearchFilters = {}, limit = 50, offset = 0) {
    try {
      const where: any = {};

      if (filters.status?.length) {
        where.status = { in: filters.status };
      }

      if (filters.orderType) {
        where.orderType = filters.orderType;
      }

      if (filters.userId) {
        where.userId = filters.userId;
      }

      if (filters.dateFrom || filters.dateTo) {
        where.createdAt = {};
        if (filters.dateFrom) where.createdAt.gte = filters.dateFrom;
        if (filters.dateTo) where.createdAt.lte = filters.dateTo;
      }

      const orders = await this.db.order.findMany({
        where,
        include: {
          orderItems: {
            include: {
              pizzaSize: true,
              pizzaCrust: true,
              pizzaSauce: true,
              toppings: {
                include: {
                  pizzaTopping: true
                }
              }
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset
      });

      const total = await this.db.order.count({ where });

      return { orders, total };
    } catch (error) {
      this.handleError(error, 'Get Orders');
    }
  }

  // Update order status
  async updateOrderStatus(orderId: string, status: OrderStatus, notes?: string) {
    try {
      const order = await this.db.order.update({
        where: { id: orderId },
        data: { 
          status,
          notes: notes ? `${notes}` : undefined,
          updatedAt: new Date()
        }
      });

      return order;
    } catch (error) {
      this.handleError(error, 'Update Order Status');
    }
  }

  // Get user's order history
  async getUserOrderHistory(userId: string, limit = 20, offset = 0) {
    try {
      const orders = await this.db.order.findMany({
        where: { userId },
        include: {
          orderItems: {
            include: {
              pizzaSize: true,
              pizzaCrust: true,
              pizzaSauce: true,
              toppings: {
                include: {
                  pizzaTopping: true
                }
              }
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset
      });

      const total = await this.db.order.count({ where: { userId } });

      return { orders, total };
    } catch (error) {
      this.handleError(error, 'Get User Order History');
    }
  }

  // Validate pricing calculations
  async validatePricing(items: CartItem[], orderType: 'PICKUP' | 'DELIVERY', expectedTotals: {
    subtotal: number;
    tax: number;
    deliveryFee: number;
    total: number;
  }) {
    try {
      // Get current settings directly
      const settings = await this.db.appSetting.findMany({
        where: {
          key: { in: ['taxRate', 'deliveryFee', 'minimumOrder'] }
        }
      });

      const settingsMap = settings.reduce((acc, setting) => {
        acc[setting.key] = setting.value;
        return acc;
      }, {} as Record<string, string>);

      const taxRate = (parseFloat(settingsMap.taxRate || '8.25')) / 100;
      const deliveryFeeAmount = parseFloat(settingsMap.deliveryFee || '3.99');
      const minimumOrderAmount = parseFloat(settingsMap.minimumOrder || '15.00');

      // Calculate expected values
      const calculatedSubtotal = items.reduce((sum, item) => sum + item.totalPrice * item.quantity, 0);
      const calculatedTax = +(calculatedSubtotal * taxRate).toFixed(2);
      const calculatedDeliveryFee = orderType === 'DELIVERY' && calculatedSubtotal < minimumOrderAmount ? deliveryFeeAmount : 0;
      const calculatedTotal = +(calculatedSubtotal + calculatedTax + calculatedDeliveryFee).toFixed(2);

      // Verify calculations match (within 1 cent for rounding)
      const isValid = 
        Math.abs(calculatedSubtotal - expectedTotals.subtotal) <= 0.01 && 
        Math.abs(calculatedTax - expectedTotals.tax) <= 0.01 && 
        Math.abs(calculatedDeliveryFee - expectedTotals.deliveryFee) <= 0.01 &&
        Math.abs(calculatedTotal - expectedTotals.total) <= 0.01;

      return {
        isValid,
        calculated: {
          subtotal: calculatedSubtotal,
          tax: calculatedTax,
          deliveryFee: calculatedDeliveryFee,
          total: calculatedTotal
        },
        provided: expectedTotals
      };
    } catch (error) {
      this.handleError(error, 'Validate Pricing');
    }
  }

  // Create pricing snapshots for historical accuracy
  private async createPricingSnapshots(tx: any, orderId: string, items: CartItem[]) {
    try {
      const snapshots = [];

      for (const item of items) {
        // Size snapshot
        snapshots.push({
          id: this.generateId(),
          orderId,
          componentType: 'SIZE',
          componentId: item.size.id,
          componentName: item.size.name,
          snapshotPrice: item.size.basePrice,
          createdAt: new Date()
        });

        // Crust snapshot
        snapshots.push({
          id: this.generateId(),
          orderId,
          componentType: 'CRUST',
          componentId: item.crust.id,
          componentName: item.crust.name,
          snapshotPrice: item.crust.priceModifier,
          createdAt: new Date()
        });

        // Sauce snapshot
        snapshots.push({
          id: this.generateId(),
          orderId,
          componentType: 'SAUCE',
          componentId: item.sauce.id,
          componentName: item.sauce.name,
          snapshotPrice: item.sauce.priceModifier,
          createdAt: new Date()
        });

        // Topping snapshots
        if (item.toppings && item.toppings.length > 0) {
          for (const topping of item.toppings) {
            snapshots.push({
              id: this.generateId(),
              orderId,
              componentType: 'TOPPING',
              componentId: topping.id,
              componentName: topping.name,
              snapshotPrice: topping.price,
              createdAt: new Date()
            });
          }
        }
      }

      // Create all snapshots in batch using createMany for better SQL safety
      if (snapshots.length > 0) {
        await tx.priceSnapshot.createMany({
          data: snapshots
        });
      }

    } catch (error) {
      console.error('Failed to create pricing snapshots:', error);
      // Don't throw error to avoid breaking order creation
    }
  }

  // Helper method to generate IDs (simple implementation)
  private generateId(): string {
    return `ps_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
