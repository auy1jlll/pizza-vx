const { exec } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

class DatabaseBackup {
  constructor(config) {
    this.config = {
      host: config.host || 'localhost',
      port: config.port || 5432,
      database: config.database,
      username: config.username,
      password: config.password,
      backupDir: config.backupDir || './backups'
    };
    
    // Set PGPASSWORD environment variable to avoid password prompts
    process.env.PGPASSWORD = this.config.password;
  }

  async ensureBackupDirectory() {
    try {
      await fs.access(this.config.backupDir);
    } catch {
      await fs.mkdir(this.config.backupDir, { recursive: true });
      console.log(`‚úÖ Created backup directory: ${this.config.backupDir}`);
    }
  }

  generateTimestamp() {
    const now = new Date();
    return now.toISOString()
      .replace(/[:.]/g, '-')
      .replace('T', '_')
      .slice(0, -5); // Remove milliseconds and Z
  }

  async executeCommand(command, description) {
    return new Promise((resolve, reject) => {
      console.log(`üîÑ ${description}...`);
      exec(command, (error, stdout, stderr) => {
        if (error) {
          console.error(`‚ùå Error during ${description}:`, error.message);
          reject(error);
          return;
        }
        if (stderr && !stderr.includes('NOTICE')) {
          console.warn(`‚ö†Ô∏è  Warning during ${description}:`, stderr);
        }
        console.log(`‚úÖ ${description} completed successfully`);
        resolve(stdout);
      });
    });
  }

  async backupSchema() {
    const timestamp = this.generateTimestamp();
    const schemaFile = path.join(this.config.backupDir, `schema_${this.config.database}_${timestamp}.sql`);
    
    const command = `pg_dump -h ${this.config.host} -p ${this.config.port} -U ${this.config.username} -d ${this.config.database} --schema-only --no-owner --no-privileges -f "${schemaFile}"`;
    
    await this.executeCommand(command, 'Schema backup');
    return schemaFile;
  }

  async backupData() {
    const timestamp = this.generateTimestamp();
    const dataFile = path.join(this.config.backupDir, `data_${this.config.database}_${timestamp}.sql`);
    
    const command = `pg_dump -h ${this.config.host} -p ${this.config.port} -U ${this.config.username} -d ${this.config.database} --data-only --no-owner --no-privileges --disable-triggers -f "${dataFile}"`;
    
    await this.executeCommand(command, 'Data backup');
    return dataFile;
  }

  async backupFull() {
    const timestamp = this.generateTimestamp();
    const fullFile = path.join(this.config.backupDir, `full_${this.config.database}_${timestamp}.sql`);
    
    const command = `pg_dump -h ${this.config.host} -p ${this.config.port} -U ${this.config.username} -d ${this.config.database} --no-owner --no-privileges -f "${fullFile}"`;
    
    await this.executeCommand(command, 'Full backup (schema + data)');
    return fullFile;
  }

  async backupPrismaSchema() {
    const timestamp = this.generateTimestamp();
    const prismaFile = path.join(this.config.backupDir, `prisma_schema_${timestamp}.prisma`);
    
    try {
      // Copy the Prisma schema file
      const schemaPath = './prisma/schema.prisma';
      await fs.copyFile(schemaPath, prismaFile);
      console.log(`‚úÖ Prisma schema backed up to: ${prismaFile}`);
      return prismaFile;
    } catch (error) {
      console.warn(`‚ö†Ô∏è  Could not backup Prisma schema: ${error.message}`);
      return null;
    }
  }

  async cleanupOldBackups(daysToKeep = 7) {
    try {
      const files = await fs.readdir(this.config.backupDir);
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

      let deletedCount = 0;

      for (const file of files) {
        const filePath = path.join(this.config.backupDir, file);
        const stats = await fs.stat(filePath);
        
        if (stats.mtime < cutoffDate && (file.endsWith('.sql') || file.endsWith('.prisma'))) {
          await fs.unlink(filePath);
          deletedCount++;
          console.log(`üóëÔ∏è  Deleted old backup: ${file}`);
        }
      }

      if (deletedCount > 0) {
        console.log(`‚úÖ Cleaned up ${deletedCount} old backup files`);
      } else {
        console.log(`‚úÖ No old backups to clean up`);
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è  Error during cleanup: ${error.message}`);
    }
  }

  async createBackup(options = {}) {
    const {
      schema = true,
      data = true,
      full = false,
      prisma = true,
      cleanup = true
    } = options;

    console.log('üöÄ Starting database backup process...\n');

    try {
      await this.ensureBackupDirectory();

      const results = {
        timestamp: this.generateTimestamp(),
        files: {}
      };

      // Create different types of backups based on options
      if (full) {
        results.files.full = await this.backupFull();
      } else {
        if (schema) {
          results.files.schema = await this.backupSchema();
        }
        if (data) {
          results.files.data = await this.backupData();
        }
      }

      if (prisma) {
        results.files.prisma = await this.backupPrismaSchema();
      }

      if (cleanup) {
        await this.cleanupOldBackups();
      }

      console.log('\nüéâ Backup process completed successfully!');
      console.log('üìÅ Backup files created:');
      Object.entries(results.files).forEach(([type, file]) => {
        if (file) console.log(`   ${type}: ${file}`);
      });

      return results;

    } catch (error) {
      console.error('‚ùå Backup process failed:', error.message);
      throw error;
    }
  }

  async restoreFromBackup(backupFile, options = {}) {
    const { dropExisting = false } = options;

    console.log(`üîÑ Starting restore from: ${backupFile}`);

    try {
      let command;

      if (dropExisting) {
        // Warning: This will drop all existing data
        console.log('‚ö†Ô∏è  WARNING: Dropping existing database content...');
        command = `psql -h ${this.config.host} -p ${this.config.port} -U ${this.config.username} -d ${this.config.database} -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"`;
        await this.executeCommand(command, 'Dropping existing schema');
      }

      command = `psql -h ${this.config.host} -p ${this.config.port} -U ${this.config.username} -d ${this.config.database} -f "${backupFile}"`;
      await this.executeCommand(command, 'Database restore');

      console.log('‚úÖ Database restored successfully!');

    } catch (error) {
      console.error('‚ùå Restore failed:', error.message);
      throw error;
    }
  }
}

// Example usage and configuration
async function main() {
  // Configuration - replace with your actual database details
  const config = {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    database: process.env.DB_NAME || 'pizzax',
    username: process.env.DB_USER || 'auy1jll66',
    password: process.env.DB_PASSWORD || '_Zx-nake_6172',
    backupDir: './backups91125'
  };

  const backup = new DatabaseBackup(config);

  try {
    // Create different types of backups
    await backup.createBackup({
      schema: true,    // Backup database schema
      data: true,      // Backup database data
      full: false,     // Create full backup instead of separate schema/data
      prisma: true,    // Backup Prisma schema file
      cleanup: true    // Clean up old backups
    });

    // Example: Restore from a backup file
    // await backup.restoreFromBackup('./backups/full_mydb_2024-01-15_14-30-22.sql', {
    //   dropExisting: true
    // });

  } catch (error) {
    console.error('Backup failed:', error);
    process.exit(1);
  }
}

// Export the class for use in other files
module.exports = DatabaseBackup;

// Run if this file is executed directly
if (require.main === module) {
  main();
}